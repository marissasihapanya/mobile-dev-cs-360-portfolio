The goal of EventUp! is to provide users with an all-in-one toolkit to manage their events and see them on an interface pushed from the cloud. It addresses the user needs of seeing, adding, deleting, and editing events. It also addresses the user need of portability via mobile interfaces in a mobile application.
The following screens were necessary: launcher, login, homepage (displaying all events), editing event, adding event, SMS signup. Each screen composes a core functionality of EventUp! that users need to manage events. They allow users to perform all actions, so it was natural to center the users during the design process. The homepage of the UI design used a GridLayout to display events. Each column made a different component of the event. The homepage displayed event name, date, info; delete and edit buttons resided next to these elements. The GridLayout encompassed each element in a clean fashion to uphold usability and cleanliness. Such a layout also encouraged users to think sequentially when seeing an event. The name is the most important aspect, with the date the natural follow-up, and then the information for users to read more about each event. The action buttons lay next to these elements, leading users to them once event details were read. This design was particularly successful because of the psychological suggestion of sequencing.
Before I approached coding, I fleshed out all layout files with the buttons and elements in their correct positioning. Come to find out, upon emuation launch, the layout positionings do not reflect from the code. So, I then tackled hard-coding the positioning of each element in the layout file. When everything looked clean, I started coding in the Java class files for the functionality of each screen. I made sure the homepage was intact and functioning first. After that, I focused on the methods that users would use: editing and deleting. I went with what was most important first, which was what the user sees after they log in. My thought process was modularized, and it allowed me to code in functional pieces to ensure the app was operating properly. This made for a seamless final product, and when I think back on it, my pathway and thought approach was clear and meaningful. I will continue to code this way in the future. Prioritization and breaking things down to their base components is useful and significant.
For testing, I constantly ran the emulation after I made code changes, and simulated a user's actions to ensure the code was working as intended. This process is important -- thinking in terms of what the user will do allows you to see potholes in your logic and your implementation. It is important to constantly run your code instead of coding without iterative, live checks. For example, after adding an event to the database, that event needs to populate in the homepage. I first made sure the database updates were being made. Then I made sure it would populate on the UI. This is the part that was especially challenging and where I had to innovate. I had to make an AddEventLauncher which sent back an intent with data that was added to an event by the user. From that intent data, in the main activity, I developed another method to add the new event to the grid. This is where I learned that you can add views to your layout programatically using the addView function. I took advantage of this and finally learned how I could update a layout dynamically! That was the biggest challenge. 
I think the main component that really demonstrated my skills was my code modularization and such usage throughout my application to make everything function smoothly. I am pretty proud of how I used methods throughout my code, and seamlessly linked every screen and every action together. It really demonstrates my ability to ensure that the backend of the big picture is pulling everything together and upholding it.
